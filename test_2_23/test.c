#define _CRT_SECURE_NO_WARNINGS
//#include <stdio.h>

//证明整型在内存中存储的是补码
//int main()
//{
//	int num1 = 1;
//	//00000000 00000000 00000000 00000001   1的补码
//	int num2 = -1;
//	//11111111 11111111 11111111 11111111  -1的补码
//	//注：每四个2进制位可以组成一个十六进制：ffffff
//	printf("%x\n", num1);//1
//	printf("%x\n", num2);//fffffff
//	return 0;
//}



//#include <stdio.h>
//
////原码、反码、补码的转化规则
//int main()
//{
//	//正整数的原码、反码、补码相同
//	int num1 = 5;
//	//00000000 00000000 00000000 00000101  num1的补码
//
//	//负整数的原码、反码、补码转化
//	int num2 = -5;
//	//10000000 00000000 00000000 00000101  原码
//	//（原码符号位不变，其他位取反）
//	//11111111 11111111 11111111 11111010  反码
//	//（反码+1）
//	//11111111 11111111 11111111 11111011  补码
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	char a = -1;
//	//默认是有符号数
//	//10000001 原码
//	//11111110 反码
//	//11111111 补码
//	//11111111 11111111 11111111 11111111 整型提升
//	//11111111 截取(补码）
//	//10000001 原码（-1）
//
//	signed char b = -1;
//	//b 和 a一样
//
//	unsigned char c = -1;
//	//10000001 原码
//	//11111110 反码
//	//11111111 补码
//	//11111111 11111111 11111111 11111111 整型提升
//	//11111111 截取 --无符号数：255
//
//	printf("a=%d,b=%d,c=%d\n", a, b, c);//-1 -1，255
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	char a = -128;
//	//10000000 -- 补码
//	//因为是无符号整型打印，需要整型提升
//	//11111111 11111111 11111111 10000000  -- 4294967168（结果）
//	printf("%u\n", a);//4294967168
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	char a = 128;
//	//10000000
//	//11111111 11111111 11111111 10000000 整型提升
//	//-- 4294967168（结果）
//	printf("%u\n", a);//4294967168
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	int a = -20;
//	//10000000 00000000 00000000 00010100 原码
//	//11111111 11111111 11111111 11101011 反码
//	//11111111 11111111 11111111 11101100 补码
//	unsigned int b = 10;
//	//11111111 11111111 11111111 11101100 补码（-20）
//	//00000000 00000000 00000000 00001010 补码 （10）
//	//11111111 11111111 11111111 11110110 运算结果(补码)
//	//11111111 11111111 11111111 11110101
//	//10000000 00000000 00000000 00001010  -10：结果
//	printf("%d\n", a + b);
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	unsigned int i;
//	//为什么进行了死循环？
//	//i是无符号整型
//	//i = 0;执行i--的时候
//	//00000000 00000000 00000000 00000000  0的补码
//	//11111111 11111111 11111111 11111111  -1的补码（无符号数，最高位没有正负之分）
//	//4294967295(-1的时候的值）
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}




//#include <stdio.h>
//#include <string.h>
//
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//11111111  -1的补码
//		//11111110  -2的补码
//		//11111101  -3的补码
//		//……
//		//10000000  -128的补码
//		//01111111   127的补码
//		//……
//		//00000000   0的补码('\0')
//	}
//	printf("%d\n", strlen(a));//255
//	return 0;
//}



//#include <stdio.h>
//
//unsigned char i;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hehe\n");
//		//11111111 i为255的时候
//		//00000000 255+1后的值
//		//所以为死循环
//	}
//	return 0;
//}



//分析大端小端字节序的排列方式
//#include <stdio.h>
//
//int main()
//{
//	int num = 0x11223344;
//	float data = 5.5;
//	//101.1
//	//01000000101100000000000000000000
//	//40b00000：十六进制形式
//	return 0;
//}



//判断当前机器是大端还是小端字节序
//#include <stdio.h>

//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;
//
//	if (*p == 1)
//	{
//		printf("小端字节序\n");
//	}
//	else
//	{
//		printf("大端字节序\n");
//	}
//	return 0;
//}



//#include <stdio.h>
//#include <limits.h>
//#include <float.h>
////判断当前机器是大端还是小端字节序
//int judge(int a)
//{
//	char* p = (char*)&a;
//	return *p;//如果小端，直接返回1，大端返回0
//}
//
//int main()
//{
//	int a = 1;
//	
//	if (judge(a) == 1)
//	{
//		printf("小端字节序\n");
//	}
//	else
//	{
//		printf("大端字节序\n");
//	}
//	return 0;
//}



//#include <stdio.h>
//
//int main()
//{
//	int num = 9;
//	float* p = (float*)&num;
//
//	printf("%d\n", num);//9
//	printf("%f\n", *p);//0.000000
//	//分析为什么是0.000000
//	//00000000 00000000 00000000 00001001  9的补码
//	//浮点数中看到的形式
//	//0 00000000 00000000000000000001001
//	//相当于0.00000000000000000001001 * (1 - 2^-126)
//	//这个数非常小，而浮点数默认取小数点后6位，所以为0.000000
//
//	*p = 9.0;
//	//1001.0
//	//1.001 * 2^3
//	//S = 0,E = 2, M = 1.001
//	//可以写出*p的的二进制序列
//	//0 10000010 00100000000000000000000 *p的二进制序列
//	//化为整数：1091567616
//	printf("%d\n", num);//1091567616
//	printf("%f\n", *p);//9.000000
//	return 0;
//}



#include <stdio.h>

int main()
{
	float num = 5.5;
	//101.1 --> 1.011
	//S = 0,E = 2, M = 1.011 --> 得出二进制序列
	//0 10000001 01100000000000000000000  num的二进制序列
	int* p = (int*)&num;
	//01000000101100000000000000000000  结果：1085276160
	printf("%f\n", num);//5.500000
	printf("%d\n", *p);//1085276160

	*p = 5;
	//01000000 10110000 00000000 00000000序列变为：
	//00000000 00000000 00000000 00000101  5
	//转化为float类型
	//0 00000000 00000000000000000000101  
	//结果：0.00000000000000000000101 * 2 ^ (-126);（极小的数）
	//转为float即为0.000000
	printf("%f\n", num);//0.000000
	printf("%d\n", *p);//5
	return 0;
}