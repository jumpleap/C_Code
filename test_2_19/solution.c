#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//短路运算符的特点
//&&：如果第一个操作符为假，则不执行后面的代码
//||：如果第一个操作符为真，则不执行后面的代码

//int main()
//{
//	int a = 0, b = 1, c = 2;
//
//	//int d = a++ && b++ && c;
//	//a=0为假，后置++先使用再++
//	//printf("a=%d,b=%d,c=%d,d=%d\n", a, b, c, d);//1，1，2，0
//
//	int d = a++ || b ++ || c++;
//	//a为0，为假，b=1为真
//	printf("a=%d,b=%d,c=%d,d=%d\n", a, b, c, d);//1,2,2,1
//	return 0;
//}



//%和/操作符的特点
// 整数除法：得到的结果是整数，舍弃了小数部分
// 小数除法：得到的结果是小数，两个操作数中必有一个浮点数
// %的特点：只能进行整数之间的取模，浮点数之间不能进行取模
//int main()
//{
//	int a = 9;
//	int b = 2;
//
//	int c = a / b;//整数除法
//	double d = a / 2.0;//小数除法，有一方为浮点数
//	printf("%d %lf\n", c, d);
//
//	int e = a % b;//整数能进行取模运算
//	//int f = a % 3.0;//浮点数不能进行取模运算
//
//	return 0;
//}



//逗号表达式的特点：当运算中有多个逗号隔开的表达式，最后一个表达式是结果
//int main()
//{
//	int a = 1;
//	int b = 1;
//	int num = (a++, b++, a);//最后一个表达式a为结果
//	printf("%d\n", num);//2
//	return 0;
//}




////当函数的返回值没有写的时候，默认返回的是int
//swap()
//{
//	int num = 10;
//	//当没有写返回值的时候，结果返回的是随机值
//	return num;
//}
//
//int main()
//{
//	int res = swap();
//	printf("%d\n", res);//10
//	return 0;
//}




// 字符串或数组在进行传参的时候把数组名传过去，形参中接收到的是什么？
//形参收到的是数组或字符串的首元素地址

//void test1(char* ch)
//{
//	//查看形参的地址
//	printf("%p\n", ch);
//}
//
//void test2(int* arr)
//{
//	//查看形参的地址
//	printf("%p\n", arr);
//}
//
//int main()
//{
//	char ch[100] = "abcdef";
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	//形参的地址和字符串/数组首元素的地址进行比较
//	test1(ch);
//	printf("ch[0] = %p\n", &ch[0]);
//	test2(arr);
//	printf("arr[0] = %p\n", &arr[0]);
//	return 0;
//}



//建议：当指针的内容不需要改变的时候，加上const，
//const使指针指向的内容不能改变（即加上const后具有健壮性）
//void test(const char* arr)
//{
//	//*arr = 'a';//错误，加上const后不能修改arr的值
//}
//
//int main()
//{
//	char arr[100] = "abcdfhgeh";
//	test(arr);
//	return 0;
//}




//怎么证明数据在内存中存储的是补码？
//使用负数证明，把补码中存储的值按照十六进行打印
//注：我们还可以使用调试来查看a在内存中的存储
//int main()
//{
//	int a = -1;
//	//10000000 00000000 00000000 00000001 原码
//	//11111111 11111111 11111111 11111110 反码
//	//11111111 11111111 11111111 11111111 补码
//	//四个二进制位是一个16进制位
//	//ffffffff
//	printf("%x\n", a);//ffffffff
//	return 0;
//}



//既然内存中存储的是补码，那么在控制台上打印的数值是补码吗？为什么？
//不是，打印是十进制数，补码需要转化为原码，在由原码转化为十进制

//int main()
//{
//	int a = -1;
//	//10000000 00000000 00000000 00000001 原码
//	//11111111 11111111 11111111 11111110 反码
//	//11111111 11111111 11111111 11111111 补码
//	printf("%d\n", a);//-1
//	//注意：若是按照十六进制打印，则打印的补码（因为%x是打印无符号数，原码、反码、补码均相同）
//	return 0;
//}




//补码变成原码的两种形式
//1)-1.取反 2）取反 +1
//int main()
//{
//	int a = -2;
//	//11111111 11111111 11111111 11111110 补码
//
//	//变回原码:法一
//	//11111111 11111111 11111111 11111110 补码
//	//11111111 11111111 11111111 11111101 反码
//	//10000000 00000000 00000000 00000010 原码 -2
//
//	//法二
//	// 11111111 11111111 11111111 11111110 补码
//	// 10000000 00000000 00000000 00000001 取反
//	// 10000000 00000000 00000000 00000010 +1 -2
//	return 0;
//}




//正/负整数的原码、反码、补码规则
//正整数和负整数的二进制表示形式？
//整数的表示形式是原码、反码、补码
//正整数的表示形式均相同
//负整数的表示形式：原码；反码 = 原码符号位不变 + 其他位按位取反、

//int main()
//{
//	int a = 1;
//	//00000000 00000000 00000000 00000001 补码
//	printf("%x\n", a);//%x把补码按照十六进制打印 ：1
//	
//	int b = -1;
//	//10000000 00000000 00000000 00000001 原码
//	//11111111 11111111 11111111 11111110 反码
//	//11111111 11111111 11111111 11111111 补码
//	//ffffff --> 十六进制形式
//	printf("%x\n", b);//ffffffff
//	return 0;
//}



//说说C语言中#include <stdio.h>是什么意思
//#include 是预处理指令
//stdio : standard input output --> 标准输入输出
//.h表示这是一个头文件




//为什么long型的排名明明在int型的后面，为什么两者的所占的字节数相等？
//C语言标准下： sizeof(long) >= sizeof(int)
//int main()
//{
//	//int的值最大值是2147483647
//	int a = 2147483647;
//	long b = 2147483647;
//	//注：两者的最大值均是2^31-1;
//	printf("%d\n", a);
//	return 0;
//}




//求出C语言中各个数据类型所占的字节空间
//int main()
//{
//	printf("%d\n", sizeof(char));//1
//	printf("%d\n", sizeof(short));//2
//	printf("%d\n", sizeof(int));//4
//	printf("%d\n", sizeof(long));//4
//	printf("%d\n", sizeof(long long));//8
//	printf("%d\n", sizeof(float));//4
//	printf("%d\n", sizeof(double));//8
//	return 0;
//}




//全局变量和局部变量的区别？
//全局变量具有全局性，在源程序中均可使用全局变量
//局部变量具有局部性，即局限于一个{}中，只能在{}中使用
//注：当局部变量和全局变量名字相同时，在使用时，优先使用局部变量

//int num = 10;
//int main()
//{
//	{
//		int num = 20;
//		printf("%d\n", num);//20
//	}
//	printf("%d\n", num);//10
//	return 0;
//}




//全局变量和局部变量的作用域和生命周期？
//作用域
//全局变量：全局变量的作用域在整个工程内，即整个工程内那点均可使用
//局部变量：在自己的{}中
//生命周期
//全局变量：全局变量的生命周期和整个工程的生命周期一样
//局部变量：出了{}后没有作用

//int main()
//{
//	{
//		int num = 10;
//	}
//	//printf("%d\n", num);//错误，num的变量的作用域和生命周期在自己所在{}中
//	return 0;
//}

//注：我们不推荐大量使用全局变量，因为全局变量容易被改变，一不小心就会使程序崩溃




//C语言中常量的种类及它们的使用形式？
//字面常量：3，5，'a',"abcd"
//const定义的常变量：const int a = 10; a不可在改变
//#define定义的标识符常量 ： #define MAX 10
//枚举常量： enum  Grade{ A,B,C,D};
//注：常量一般需要使用大写字面表示

//int main()
//{
//	//字面常量
//	3, 5, "agcgs";
//	//const定义的常变量
//
//	const int num = 10;
//	//num = 11;//不可改变
//	
//	//#define定义的标识符常量
//#define MAX 10
//	printf("%d\n", MAX);//10
//
//	//枚举常量
//	enum Grade
//	{
//		A,//0
//		B,//1
//		C,//2
//		D//3
//	};
//	printf("%d\n", A);//0
//	printf("%d\n", B);//1
//	printf("%d\n", C);//2
//	printf("%d\n", D);//3
//	return 0;
//}




//scanf()和printf()函数的返回值是什么类型？并查看它们的函数模型
//scanf()和printf()函数是int的返回类型
//cplusplus.com查看函数模型

//int main()
//{
//	int num = 0;
//	int ret = scanf("%d", &num);
//	int res = printf("%d\n", num);
//	printf("%d %d\n", ret, res);//1 2
//	return 0;
//}




//C语言中的字符串结束标志是什么？如何查看一个字符串中是否有结束标志？
//结束标志：'\0'，调试查看

int main()
{
	char str[100] = "abcdhdde";
	return 0;
}


//代码验证：为什么C语言中0表示假，非0表示真
//int main()
//{
//	int a = 0;
//	int b = -1;
//	int c = 1;
//
//	if (a)
//	{
//		printf("haha\n");
//	}
//
//	if (!a)
//	{
//		printf("hehe\n");
//	}
//
//	if (b)
//	{
//		printf("hihi\n");
//	}
//
//	if (c)
//	{
//		printf("hoho\n");
//	}
//	return 0;
//}